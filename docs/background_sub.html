<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>background_sub API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>background_sub</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cv2
import time
import numpy as np
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score

# Creates background mask or background image depending on what is desired
def create_background(fg_mask, img, color = False):
    &#34;&#34;&#34;
    Inverts the foreground mask to create the background image.

    Parameters
    ----------
    color : bool, optional
        If set to true, the function will return the background in color; otherwise it will be a binary image.
    fg_mask : Numpy array
        Binary image containing white bounding boxes around foreground objects.
    img : Numpy array
        Original image of the foreground mask.

    Returns
    -------
    bg : Numpy array
        Background image in color or as binary image.
    
    Notes
    -----
    create_background on its own does not decide when it is best to update the background. Using this function without deciding when to update the background will negate background subtraction.
    &#34;&#34;&#34;
    bg = cv2.bitwise_not(fg_mask)
    if color is True:
        bg = cv2.bitwise_and(img,img, mask = bg) #use this line if color is desired over binary mask
    return bg

# expands bounding box to include background pixels for better feature detection
def expand_bounding_box(ystart, xstart, ystop, xstop, img_xsize, img_ysize, advancement):
    &#34;&#34;&#34;
    expand_bounding_box takes bounding boxes and expands them in all directions by the desired amount. 
    
    Parameters
    ----------
    ystart : int
        The top left most y coorindate for the bounding box.
    xstart : int
        The top left most x coordinate for the bounding box.
    ystop : int
        The bottom right most y coordinate for the bounding box.
    xstop : int
        The bottom right most x coordinate for the bounding box.
    img_xsize : int
        Image Width.
    img_ysize : int
        Image Height.
    advancement : int
        How many pixels to expand the bounding box by.

    Returns
    -------
    ystart : int
        New top left most y coordinate.
    xstart : int
        New top left most x coordinate.
    ystop : int
        New bottom right most x coordinate.
    xstop : int
        New bottom right most x coordinate.
        
    Notes
    -----
    This allows the foreground mask to include some background pixles in addition to the foreground. This allows for better feature detection when using openMVG.
    
    &#34;&#34;&#34;
    ystart = max(0, ystart-advancement)
    xstart = max(0, xstart-advancement)
    ystop = min(ystop+advancement, img_ysize)
    xstop = min(xstop+advancement, img_xsize)
    return ystart, xstart, ystop, xstop

def kmeans_helper(image, fg_advancement, bg_advancement, grid_width = 45):
    &#34;&#34;&#34;
    Cluster nonzero pixels and return bounding boxes around each cluster.

    Parameters
    ----------
    image : Numpy array
        Binary image from frame subtraction.
    grid_width : int 
        Determines the size of the grid squares to be used for grid search algorithm. Higher value = less time, less accuracy. Lower value = more time, more accuracy.
    fg_advancement : int
        The number of pixels the bounding box for foreground image is to be expanded by.
    bg_advancement : int 
        The number of pixels the bounding box for background image is to be expanded by.

    Returns
    -------
    success : bool
        True, if clustering was successful.
    foreground_mask : Numpy array
        Binary image containing bounding boxes around foreground clusters. If success = false, this will be type None.
    fg_to_background : Numpy array
        foreground mask with different advancement value that will be turned into the background image.
    box_areas : list of ints
        List containing the area of each bounding box. Areas are calculated using foreground image boxes.
    Notes
    -----
    To reduce computational complexity, a grid search algorithm is used before kmeans clustering to reduce the amount of points. From here the points from grid search are used for clustering. Then bounding boxes are drawn around each of those clusters. This comes with the trade off of potentially losing some accuracy.
    &#34;&#34;&#34;
    # initialize success
    success = True
    
    # find grid bondary points
    data = np.nonzero(image)
    topLeft = ( data[1].min(), data[0].min() )
    bottomRight = ( data[1].max(), data[0].max() ) 

    # creating the grid
    # grid_width = 45     #width of each grid square
    centroids = []      #centroid for each grid
    end_x = bottomRight[0] - topLeft[0]
    end_y = bottomRight[1] - topLeft[1]
    #start_grid = time.time()

    # height, width for image array
    ys_to_search = np.linspace(0,end_y,int(end_y/grid_width),dtype=int)
    xs_to_search = np.linspace(0,end_x,int(end_x/grid_width),dtype=int)
    for i in range(len(xs_to_search)-1):
        for j in range(len(ys_to_search)-1):
            #obtain new grid slice
            grid = image[(ys_to_search[j] + topLeft[1]):(ys_to_search[j+1] + topLeft[1]), (xs_to_search[i] + topLeft[0]):(xs_to_search[i+1] 
                                                                                                                          + topLeft[0])]
            
            #find non-zero points
            nonzero_xs, nonzero_ys = np.nonzero(grid)
            
            #need to bring nonzero pixels into image coordinates
            nonzero_xs += xs_to_search[i] + topLeft[0]
            nonzero_ys += ys_to_search[j] + topLeft[1]
            if len(nonzero_ys) &gt; 1 or len(nonzero_xs) &gt; 1:
                x_avg = np.mean(nonzero_xs)
                y_avg = np.mean(nonzero_ys)
                centroids.append([x_avg,y_avg])
                
    # print(&#34;Size of grids: &#34;, grid_width, &#34;x&#34;, grid_width )
    # print(&#34;Total Number of centroids after grid algorithm: &#34;,  len(centroids))
    # print(&#34;Time taken to form grid and calculate centroids: &#34;, time.time() - start_grid)
    centroids = np.asarray(centroids).reshape(-1,2)

    #calculate centroids
    try:
        #run silhouette algorithm (2 to 11 clusters)
        best_labels = None
        best_sil_score = -1
        #start_Ctime = time.time() 
        for k in range(2,11):
            kmeans = KMeans(n_clusters=k, init=&#39;k-means++&#39;)
            kmeans.fit(centroids)
            silhouette_avg = silhouette_score(centroids, kmeans.labels_)
            if silhouette_avg &gt; best_sil_score:
                best_centroids = kmeans.cluster_centers_
                best_labels = kmeans.labels_
                best_sil_score = silhouette_avg
        # print(&#34;Time taken to run &#34;, k, &#34; kmeans: &#34;, time.time() - start_Ctime)
        clusters = [centroids[best_labels == label] for label in np.unique(best_labels)]
        # print(&#39;Number of clusters is: &#39;, len(clusters))

        # establish bounding box for each cluster
        img = np.zeros((image.shape[0],image.shape[1]), np.uint8)
        box_areas = [] # list of containing each box area
        for c in clusters:
            # find bounding values of cluster (min values)
            (xstart, ystart), (xstop, ystop) = c.min(0), c.max(0) 
            # expand bounding box to include feature points for foreground (do not exceed image bounds)
            ystart, xstart, ystop, xstop = expand_bounding_box( int(ystart), int(xstart), int(ystop), int(xstop), image.shape[1], image.shape[0],
                                                               fg_advancement)
            foreground_mask = cv2.rectangle(img, (xstart, ystart), (xstop, ystop), color = (255,255,255), thickness=-1)
            area = (xstop - xstart) * (ystop - ystart)
            box_areas.append(area) 
            # expand bounding box for what will become the background mask
            (xstart, ystart), (xstop, ystop) = c.min(0), c.max(0) 
            ystart, xstart, ystop, xstop = expand_bounding_box( int(ystart), int(xstart), int(ystop), int(xstop), image.shape[1], image.shape[0],
                                                               bg_advancement)
            fg_to_background = cv2.rectangle(img, (xstart, ystart), (xstop, ystop), color = (255,255,255), thickness=-1)

    except:
        success = False
        foreground_mask = None
        
    return success, foreground_mask, fg_to_background, box_areas

def create_fg_mask(fg_binary, image,fg_advancement, bg_advancement, color = False):
    &#34;&#34;&#34;
    Create foreground image using foreground binary image from background subtraction.

    Parameters
    ----------
    fg_binary : Numpy array
        Binary image obtained from frame subtraction.
    color : bool, optional
        If set to true, the function will return the foreground in color; otherwise it will be a binary image.
    fg_advancement : int
        The number of pixels the bounding box for foreground image is to be expanded by.
    bg_advancement : int 
        The number of pixels the bounding box for background image is to be expanded by.
    image : Numpy array
        Original image of foreground binary.
    
    Returns
    -------
    success : bool
        True if the clustering was successful.
    fg : Numpy array
        Foreground image as either binary image or color image.
    bg : Numpy array
        Foreground mask with a different advancement value, will be inverted to be the background image. Always returns as a binary image (converted later).
    box_areas : list of ints
        List containing the area of each bounding box.
    &#34;&#34;&#34;
    success, fg, bg, box_areas = kmeans_helper(fg_binary,fg_advancement,bg_advancement)
    if color is True:
        fg  = cv2.bitwise_and(image,image, mask = fg)
    return success, fg, bg, box_areas</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="background_sub.create_background"><code class="name flex">
<span>def <span class="ident">create_background</span></span>(<span>fg_mask, img, color=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverts the foreground mask to create the background image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>color</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If set to true, the function will return the background in color; otherwise it will be a binary image.</dd>
<dt><strong><code>fg_mask</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Binary image containing white bounding boxes around foreground objects.</dd>
<dt><strong><code>img</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Original image of the foreground mask.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bg</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Background image in color or as binary image.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>create_background on its own does not decide when it is best to update the background. Using this function without deciding when to update the background will negate background subtraction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_background(fg_mask, img, color = False):
    &#34;&#34;&#34;
    Inverts the foreground mask to create the background image.

    Parameters
    ----------
    color : bool, optional
        If set to true, the function will return the background in color; otherwise it will be a binary image.
    fg_mask : Numpy array
        Binary image containing white bounding boxes around foreground objects.
    img : Numpy array
        Original image of the foreground mask.

    Returns
    -------
    bg : Numpy array
        Background image in color or as binary image.
    
    Notes
    -----
    create_background on its own does not decide when it is best to update the background. Using this function without deciding when to update the background will negate background subtraction.
    &#34;&#34;&#34;
    bg = cv2.bitwise_not(fg_mask)
    if color is True:
        bg = cv2.bitwise_and(img,img, mask = bg) #use this line if color is desired over binary mask
    return bg</code></pre>
</details>
</dd>
<dt id="background_sub.create_fg_mask"><code class="name flex">
<span>def <span class="ident">create_fg_mask</span></span>(<span>fg_binary, image, fg_advancement, bg_advancement, color=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create foreground image using foreground binary image from background subtraction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fg_binary</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Binary image obtained from frame subtraction.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If set to true, the function will return the foreground in color; otherwise it will be a binary image.</dd>
<dt><strong><code>fg_advancement</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of pixels the bounding box for foreground image is to be expanded by.</dd>
<dt><strong><code>bg_advancement</code></strong> :&ensp;<code>int </code></dt>
<dd>The number of pixels the bounding box for background image is to be expanded by.</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Original image of foreground binary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>success</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if the clustering was successful.</dd>
<dt><strong><code>fg</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Foreground image as either binary image or color image.</dd>
<dt><strong><code>bg</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Foreground mask with a different advancement value, will be inverted to be the background image. Always returns as a binary image (converted later).</dd>
<dt><strong><code>box_areas</code></strong> :&ensp;<code>list</code> of <code>ints</code></dt>
<dd>List containing the area of each bounding box.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_fg_mask(fg_binary, image,fg_advancement, bg_advancement, color = False):
    &#34;&#34;&#34;
    Create foreground image using foreground binary image from background subtraction.

    Parameters
    ----------
    fg_binary : Numpy array
        Binary image obtained from frame subtraction.
    color : bool, optional
        If set to true, the function will return the foreground in color; otherwise it will be a binary image.
    fg_advancement : int
        The number of pixels the bounding box for foreground image is to be expanded by.
    bg_advancement : int 
        The number of pixels the bounding box for background image is to be expanded by.
    image : Numpy array
        Original image of foreground binary.
    
    Returns
    -------
    success : bool
        True if the clustering was successful.
    fg : Numpy array
        Foreground image as either binary image or color image.
    bg : Numpy array
        Foreground mask with a different advancement value, will be inverted to be the background image. Always returns as a binary image (converted later).
    box_areas : list of ints
        List containing the area of each bounding box.
    &#34;&#34;&#34;
    success, fg, bg, box_areas = kmeans_helper(fg_binary,fg_advancement,bg_advancement)
    if color is True:
        fg  = cv2.bitwise_and(image,image, mask = fg)
    return success, fg, bg, box_areas</code></pre>
</details>
</dd>
<dt id="background_sub.expand_bounding_box"><code class="name flex">
<span>def <span class="ident">expand_bounding_box</span></span>(<span>ystart, xstart, ystop, xstop, img_xsize, img_ysize, advancement)</span>
</code></dt>
<dd>
<div class="desc"><p>expand_bounding_box takes bounding boxes and expands them in all directions by the desired amount. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ystart</code></strong> :&ensp;<code>int</code></dt>
<dd>The top left most y coorindate for the bounding box.</dd>
<dt><strong><code>xstart</code></strong> :&ensp;<code>int</code></dt>
<dd>The top left most x coordinate for the bounding box.</dd>
<dt><strong><code>ystop</code></strong> :&ensp;<code>int</code></dt>
<dd>The bottom right most y coordinate for the bounding box.</dd>
<dt><strong><code>xstop</code></strong> :&ensp;<code>int</code></dt>
<dd>The bottom right most x coordinate for the bounding box.</dd>
<dt><strong><code>img_xsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Image Width.</dd>
<dt><strong><code>img_ysize</code></strong> :&ensp;<code>int</code></dt>
<dd>Image Height.</dd>
<dt><strong><code>advancement</code></strong> :&ensp;<code>int</code></dt>
<dd>How many pixels to expand the bounding box by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ystart</code></strong> :&ensp;<code>int</code></dt>
<dd>New top left most y coordinate.</dd>
<dt><strong><code>xstart</code></strong> :&ensp;<code>int</code></dt>
<dd>New top left most x coordinate.</dd>
<dt><strong><code>ystop</code></strong> :&ensp;<code>int</code></dt>
<dd>New bottom right most x coordinate.</dd>
<dt><strong><code>xstop</code></strong> :&ensp;<code>int</code></dt>
<dd>New bottom right most x coordinate.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This allows the foreground mask to include some background pixles in addition to the foreground. This allows for better feature detection when using openMVG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_bounding_box(ystart, xstart, ystop, xstop, img_xsize, img_ysize, advancement):
    &#34;&#34;&#34;
    expand_bounding_box takes bounding boxes and expands them in all directions by the desired amount. 
    
    Parameters
    ----------
    ystart : int
        The top left most y coorindate for the bounding box.
    xstart : int
        The top left most x coordinate for the bounding box.
    ystop : int
        The bottom right most y coordinate for the bounding box.
    xstop : int
        The bottom right most x coordinate for the bounding box.
    img_xsize : int
        Image Width.
    img_ysize : int
        Image Height.
    advancement : int
        How many pixels to expand the bounding box by.

    Returns
    -------
    ystart : int
        New top left most y coordinate.
    xstart : int
        New top left most x coordinate.
    ystop : int
        New bottom right most x coordinate.
    xstop : int
        New bottom right most x coordinate.
        
    Notes
    -----
    This allows the foreground mask to include some background pixles in addition to the foreground. This allows for better feature detection when using openMVG.
    
    &#34;&#34;&#34;
    ystart = max(0, ystart-advancement)
    xstart = max(0, xstart-advancement)
    ystop = min(ystop+advancement, img_ysize)
    xstop = min(xstop+advancement, img_xsize)
    return ystart, xstart, ystop, xstop</code></pre>
</details>
</dd>
<dt id="background_sub.kmeans_helper"><code class="name flex">
<span>def <span class="ident">kmeans_helper</span></span>(<span>image, fg_advancement, bg_advancement, grid_width=45)</span>
</code></dt>
<dd>
<div class="desc"><p>Cluster nonzero pixels and return bounding boxes around each cluster.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Binary image from frame subtraction.</dd>
<dt><strong><code>grid_width</code></strong> :&ensp;<code>int </code></dt>
<dd>Determines the size of the grid squares to be used for grid search algorithm. Higher value = less time, less accuracy. Lower value = more time, more accuracy.</dd>
<dt><strong><code>fg_advancement</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of pixels the bounding box for foreground image is to be expanded by.</dd>
<dt><strong><code>bg_advancement</code></strong> :&ensp;<code>int </code></dt>
<dd>The number of pixels the bounding box for background image is to be expanded by.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>success</code></strong> :&ensp;<code>bool</code></dt>
<dd>True, if clustering was successful.</dd>
<dt><strong><code>foreground_mask</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>Binary image containing bounding boxes around foreground clusters. If success = false, this will be type None.</dd>
<dt><strong><code>fg_to_background</code></strong> :&ensp;<code>Numpy array</code></dt>
<dd>foreground mask with different advancement value that will be turned into the background image.</dd>
<dt><strong><code>box_areas</code></strong> :&ensp;<code>list</code> of <code>ints</code></dt>
<dd>List containing the area of each bounding box. Areas are calculated using foreground image boxes.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>To reduce computational complexity, a grid search algorithm is used before kmeans clustering to reduce the amount of points. From here the points from grid search are used for clustering. Then bounding boxes are drawn around each of those clusters. This comes with the trade off of potentially losing some accuracy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kmeans_helper(image, fg_advancement, bg_advancement, grid_width = 45):
    &#34;&#34;&#34;
    Cluster nonzero pixels and return bounding boxes around each cluster.

    Parameters
    ----------
    image : Numpy array
        Binary image from frame subtraction.
    grid_width : int 
        Determines the size of the grid squares to be used for grid search algorithm. Higher value = less time, less accuracy. Lower value = more time, more accuracy.
    fg_advancement : int
        The number of pixels the bounding box for foreground image is to be expanded by.
    bg_advancement : int 
        The number of pixels the bounding box for background image is to be expanded by.

    Returns
    -------
    success : bool
        True, if clustering was successful.
    foreground_mask : Numpy array
        Binary image containing bounding boxes around foreground clusters. If success = false, this will be type None.
    fg_to_background : Numpy array
        foreground mask with different advancement value that will be turned into the background image.
    box_areas : list of ints
        List containing the area of each bounding box. Areas are calculated using foreground image boxes.
    Notes
    -----
    To reduce computational complexity, a grid search algorithm is used before kmeans clustering to reduce the amount of points. From here the points from grid search are used for clustering. Then bounding boxes are drawn around each of those clusters. This comes with the trade off of potentially losing some accuracy.
    &#34;&#34;&#34;
    # initialize success
    success = True
    
    # find grid bondary points
    data = np.nonzero(image)
    topLeft = ( data[1].min(), data[0].min() )
    bottomRight = ( data[1].max(), data[0].max() ) 

    # creating the grid
    # grid_width = 45     #width of each grid square
    centroids = []      #centroid for each grid
    end_x = bottomRight[0] - topLeft[0]
    end_y = bottomRight[1] - topLeft[1]
    #start_grid = time.time()

    # height, width for image array
    ys_to_search = np.linspace(0,end_y,int(end_y/grid_width),dtype=int)
    xs_to_search = np.linspace(0,end_x,int(end_x/grid_width),dtype=int)
    for i in range(len(xs_to_search)-1):
        for j in range(len(ys_to_search)-1):
            #obtain new grid slice
            grid = image[(ys_to_search[j] + topLeft[1]):(ys_to_search[j+1] + topLeft[1]), (xs_to_search[i] + topLeft[0]):(xs_to_search[i+1] 
                                                                                                                          + topLeft[0])]
            
            #find non-zero points
            nonzero_xs, nonzero_ys = np.nonzero(grid)
            
            #need to bring nonzero pixels into image coordinates
            nonzero_xs += xs_to_search[i] + topLeft[0]
            nonzero_ys += ys_to_search[j] + topLeft[1]
            if len(nonzero_ys) &gt; 1 or len(nonzero_xs) &gt; 1:
                x_avg = np.mean(nonzero_xs)
                y_avg = np.mean(nonzero_ys)
                centroids.append([x_avg,y_avg])
                
    # print(&#34;Size of grids: &#34;, grid_width, &#34;x&#34;, grid_width )
    # print(&#34;Total Number of centroids after grid algorithm: &#34;,  len(centroids))
    # print(&#34;Time taken to form grid and calculate centroids: &#34;, time.time() - start_grid)
    centroids = np.asarray(centroids).reshape(-1,2)

    #calculate centroids
    try:
        #run silhouette algorithm (2 to 11 clusters)
        best_labels = None
        best_sil_score = -1
        #start_Ctime = time.time() 
        for k in range(2,11):
            kmeans = KMeans(n_clusters=k, init=&#39;k-means++&#39;)
            kmeans.fit(centroids)
            silhouette_avg = silhouette_score(centroids, kmeans.labels_)
            if silhouette_avg &gt; best_sil_score:
                best_centroids = kmeans.cluster_centers_
                best_labels = kmeans.labels_
                best_sil_score = silhouette_avg
        # print(&#34;Time taken to run &#34;, k, &#34; kmeans: &#34;, time.time() - start_Ctime)
        clusters = [centroids[best_labels == label] for label in np.unique(best_labels)]
        # print(&#39;Number of clusters is: &#39;, len(clusters))

        # establish bounding box for each cluster
        img = np.zeros((image.shape[0],image.shape[1]), np.uint8)
        box_areas = [] # list of containing each box area
        for c in clusters:
            # find bounding values of cluster (min values)
            (xstart, ystart), (xstop, ystop) = c.min(0), c.max(0) 
            # expand bounding box to include feature points for foreground (do not exceed image bounds)
            ystart, xstart, ystop, xstop = expand_bounding_box( int(ystart), int(xstart), int(ystop), int(xstop), image.shape[1], image.shape[0],
                                                               fg_advancement)
            foreground_mask = cv2.rectangle(img, (xstart, ystart), (xstop, ystop), color = (255,255,255), thickness=-1)
            area = (xstop - xstart) * (ystop - ystart)
            box_areas.append(area) 
            # expand bounding box for what will become the background mask
            (xstart, ystart), (xstop, ystop) = c.min(0), c.max(0) 
            ystart, xstart, ystop, xstop = expand_bounding_box( int(ystart), int(xstart), int(ystop), int(xstop), image.shape[1], image.shape[0],
                                                               bg_advancement)
            fg_to_background = cv2.rectangle(img, (xstart, ystart), (xstop, ystop), color = (255,255,255), thickness=-1)

    except:
        success = False
        foreground_mask = None
        
    return success, foreground_mask, fg_to_background, box_areas</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="background_sub.create_background" href="#background_sub.create_background">create_background</a></code></li>
<li><code><a title="background_sub.create_fg_mask" href="#background_sub.create_fg_mask">create_fg_mask</a></code></li>
<li><code><a title="background_sub.expand_bounding_box" href="#background_sub.expand_bounding_box">expand_bounding_box</a></code></li>
<li><code><a title="background_sub.kmeans_helper" href="#background_sub.kmeans_helper">kmeans_helper</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>